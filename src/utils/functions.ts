import { UserInterface, generateHashInterface } from '../global'
import DB from '../database/index'
// import labels from '../config/label.config.json'
import he from 'he'
import { createHash, randomUUID } from 'crypto'
import { findOne } from '../database/functions'
import { FindOptions, Op } from 'sequelize'

export const prepareInputData = (
	model: string,
	data: Record<string, any>,
	op: 'create' | 'update' | 'both',
	user?: UserInterface
) => {
	const fields = DB[model].rawAttributes
	const neededFields = Object.keys(fields).filter(
		(x) => !fields[x]._autoGenerated //TODO: disallow update from updating primary key
	)
	const res: Record<string, any> = {}
	Object.keys(data).forEach((d) => {
		const input = d
			.split('_')
			.map((x, i) => {
				return i ? x.charAt(0).toUpperCase() + x.slice(1) : x
			})
			.join('')
		if (neededFields.includes(input)) res[input] = data[d]
	})
	return res
}

export const prepareParam = (model: string, data: any) => {
	const fields = DB[model].rawAttributes
	let neededFields = Object.keys(fields)
	neededFields = neededFields.map((n) => n.toLowerCase())
	const res: Record<string, any> = {}
	Object.keys(data).forEach((d) => {
		const input = d
			.split('_')
			.map((x, i) => {
				return i ? x.charAt(0).toUpperCase() + x.slice(1) : x
			})
			.join('')
		const i = input.toLowerCase()
		if (neededFields.includes(i)) res[input] = data[d]
	})
	return res
}

export const prepareResponseData = (data: Record<string, any>) => {
	const res: Record<string, any> = {}
	Object.keys(data).forEach((d) => {
		if (data[d] !== null) {
			if (typeof data[d] === 'object' && data[d].id) {
				res[
					d
						.split(/(?=[A-Z])/)
						.join('_')
						.toLowerCase()
				] = prepareResponseData(data[d])
			} else if (Array.isArray(data[d])) {
				res[
					d
						.split(/(?=[A-Z])/)
						.join('_')
						.toLowerCase()
				] = data[d].map((d1: any) =>
					typeof d1 === 'string' ? d1 : prepareResponseData(d1)
				)
			} else {
				let val = data[d]
				if (typeof data[d] === 'string') {
					val = he.decode(data[d])
				}
				res[
					d
						.split(/(?=[A-Z])/)
						.join('_')
						.toLowerCase()
				] = val
			}
		}
	})
	return res
}

export const prepareGetParams = (
	model: string,
	query: Record<string, any>,
	user: UserInterface,
	search_fields: string[] = []
): FindOptions => {
	const params: any = { where: {} }
	// search
	if (query.search) {
		const searchText = '%' + query.search + '%'
		params.where = {
			...params.where,
			[Op.or]: search_fields.map((s: string) => {
				const p: Record<string, any> = {}
				p[s] = { [Op.iLike]: searchText }
				return p
			}),
		}
	}
	// filter
	if (query.filter) {
		try {
			const filter = JSON.parse(query.filter)
			const fields = DB[model].rawAttributes
			const neededFields = Object.keys(fields)
			Object.keys(filter).forEach((d) => {
				const input = d
					.split('_')
					.map((x, i) => {
						return i ? x.charAt(0).toUpperCase() + x.slice(1) : x
					})
					.join('')
				if (neededFields.includes(input)) params.where[input] = filter[d]
			})
		} catch (error) {}
	}
	// sorting
	params.order = [
		[
			query.sort_field
				? query.sort_field
						.split('_')
						.map((x: string, i: number) => {
							return i ? x.charAt(0).toUpperCase() + x.slice(1) : x
						})
						.join('')
				: 'createdAt',
			query.sort_order || 'desc',
		],
	]
	if (params.include?.length) query.raw = false
	//pagination
	params.limit = query.page_size || 20
	params.offset = (Number(query.page_number || 1) - 1) * params.limit
	return params
}

export const randString = (length: number, chars: string) => {
	var mask = ''
	if (chars.indexOf('#') > -1) mask += '01234567890987654321'
	if (chars.indexOf('A') > -1) mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
	if (chars.indexOf('a') > -1) mask += 'abcdefghijklmnopqrstuvwxyz'
	var result = ''
	for (var i = length; i > 0; --i)
		result += mask[Math.floor(Math.random() * mask.length)]
	return result
}

// const l = labels as { [index: string]: any }
// export const customMessage = (text: string) => l[text]

export const generateHash = (
	text: string,
	salt?: string
): generateHashInterface => {
	const hash = createHash('sha256')
	if (salt === undefined) salt = randomUUID()
	hash.update(salt + text)
	return { salt, hash: hash.digest('base64url') }
}
export const generateId = async (model: string, length: number = 4) => {
	let id
	do {
		id = randString(length, 'A#')
	} while (
		await findOne(model, {
			where: { id },
			attributes: ['id'],
		})
	)
	return id
}
